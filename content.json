{"meta":{"title":"Song","subtitle":"自命不凡，却无足轻重","description":"Maybe i never told you.","author":"Song","url":"https://github.com/PengsongAndroid/pengsongandroid.github.com"},"pages":[{"title":"","date":"2017-04-14T06:24:53.286Z","updated":"2017-04-14T06:23:58.704Z","comments":true,"path":"baidu_verify_S28Oid6auY.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/baidu_verify_S28Oid6auY.html","excerpt":"","text":"S28Oid6auY"},{"title":"","date":"2017-03-16T07:34:33.947Z","updated":"2017-03-16T07:34:33.947Z","comments":true,"path":"about/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/about/index.html","excerpt":"","text":"个人介绍2015.5~至今, 负责公司Android客户端，主导项目重构2014.7~至今, 从事Android应用开发爱思考，爱音乐，常犯困Android开发，会点python，会点吉他上海、武汉"},{"title":"category","date":"2017-03-02T03:07:05.437Z","updated":"2017-03-02T01:54:53.378Z","comments":false,"path":"category/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/category/index.html","excerpt":"","text":""},{"title":"link","date":"2017-03-02T03:07:05.439Z","updated":"2017-03-01T09:50:32.987Z","comments":false,"path":"link/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/link/index.html","excerpt":"","text":""},{"title":"project","date":"2017-03-02T03:07:05.442Z","updated":"2017-03-01T09:50:23.070Z","comments":false,"path":"project/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/project/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-03-02T03:07:05.445Z","updated":"2017-03-02T01:54:31.953Z","comments":false,"path":"tag/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Dagger2 从生成的代码看原理","slug":"Dagger2 从生成的代码看原理","date":"2017-04-23T23:33:44.000Z","updated":"2017-04-24T07:29:52.459Z","comments":true,"path":"2017/04/24/Dagger2 从生成的代码看原理/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2017/04/24/Dagger2 从生成的代码看原理/","excerpt":"接着之前的注解，正好最近有时间，对去年大热的开源库Dagger做一个分析。首先举一个最基础的MVP模式的例子，通过使用注解","text":"接着之前的注解，正好最近有时间，对去年大热的开源库Dagger做一个分析。首先举一个最基础的MVP模式的例子，通过使用注解 首先我们从调用的入口看1DaggerMainComponent.builder().mainMoudle(new MainMoudle(this)).build().inject(this); 点进去我们可以看到DaggerMainComponent是实现的MainComponent接口，MainComponent就是我们添加了@Component注解的接口。所以我们可以推断一下，添加了@Component注解的接口，dagger会帮我们生成一个实现类。 然后看看builder方法，这个方法是直接返回了一个new的Builder对象。123public static Builder builder() &#123; return new Builder();&#125; 然后看看Builder对象是干嘛的。 1234567891011121314151617public static final class Builder &#123; private MainMoudle mainMoudle; private Builder() &#123;&#125; public MainComponent build() &#123; if (mainMoudle == null) &#123; throw new IllegalStateException(MainMoudle.class.getCanonicalName() + \" must be set\"); &#125; return new DaggerMainComponent(this); &#125; public Builder mainMoudle(MainMoudle mainMoudle) &#123; this.mainMoudle = Preconditions.checkNotNull(mainMoudle); return this; &#125;&#125; 可以看到，这个Builder类中有一个MainMoudle对象，还有一个mainMoudle提供给我们来注入对象，然后就是一个build方法返回一个DaggerMainComponent对象。接上面的说，添加了@Component注解的接口，dagger在生成Builder类时，会生成一个module对象，这个对象就是我们在注解中添加的参数，然后会生成一个方法供我们注入对象。从我们调用入口来看，先调用builder方法创建一个Builder对象，然后注入一个MainModule对象，再调用build方法，创建DaggerMainComponent对象。我们看看build方法，实际是调用了DaggerMainComponent的构造方法，调用的initialize方法：12345678private void initialize(final Builder builder) &#123; this.provideViewProvider = MainMoudle_ProvideViewFactory.create(builder.mainMoudle); this.mainPresenterProvider = MainPresenter_Factory.create(provideViewProvider); this.mainActivityMembersInjector = MainActivity_MembersInjector.create(mainPresenterProvider);&#125; 就三行代码，在分析这三行代码之前我们先想一想，实例化Activity中的presenter的步骤，首先我们需要：获取view→提供view给presenter→在Activity中注入presenter对象。有了这个思路，我们再来看看这三行代码。MainMoudle_ProvideViewFactory实现了Factory接口，Factory集成的Provider接口，Provider中有一个get方法（这点不展开说，暂时还不懂）。MainMoudle_ProvideViewFactory类主要就是提供了一个get方法，get方法是通过module的provideView方法来提供view对象。provideView就是我们之前在MainMoudle类中添加了@Provides注解的方法。然后我们返回的Factory对象会传递给MainPresenter_Factory，MainPresenter_Factory也只是保留这个对象的引用，然后在需要get方法的时候通过这个对象提供的view去实例化MainPresenter。然后MainPresenter_Factory会传递给MainActivity_MembersInjector的create方法，MainActivity_MembersInjector类实现了MembersInjector接口，MembersInjector接口有一个injectMembers方法。1234567@Overridepublic void injectMembers(MainActivity instance) &#123; if (instance == null) &#123; throw new NullPointerException(\"Cannot inject members into a null reference\"); &#125; instance.presenter = presenterProvider.get();&#125; 现在我们回头再看看我们在Activity中调用的inject方法，这个方法实际上调用的就是上面说的injectMembers方法，传入了MainActivity实例，然后直接对presenter进行赋值。而这个presenter就是我们在Activity中添加的注解。12@InjectMainPresenter presenter; 至此一个完整的注入流程就完了，写的比较凌乱，现在梳理一下整个思路。首先，我们的目的是@Inject注解对MainActivity中的presenter进行注入，我们的入口是从@Component注解开始，通过这个入口去生成Component类，@Component注解中又提供了参数module，Module类中又有一个@Provides注解这个方法提供了一个View对象。在Presenter中有一个@Inject注解的方法，Moudle中provide的view对象就被注入到presenter中，presenter实例化后又被注入到Activity，这就完成了这个demo的整个注解流程。我们的分析是顺着生成的代码，一步步查看生成代码来分析流程的，这样能弄懂对象是如何注解的，但是没法了解dagger框架的原理。我们现在从刚刚分析的流程中进行倒推，我们做的事情只是在几个需要的地方进行注解。通过这几个注解如何生成这些代码？dagger中肯定有一个存放所有注解、分析所有注解的一个关系图。","categories":[{"name":"Android日常问题","slug":"Android日常问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android日常问题/"}],"tags":[{"name":"Android, 开源库, Dagger","slug":"Android-开源库-Dagger","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-开源库-Dagger/"}]},{"title":"Android注解实践——运行时注解框架","slug":"Android注解实践——运行时注解框架","date":"2017-04-09T10:45:13.000Z","updated":"2017-04-13T10:00:03.850Z","comments":true,"path":"2017/04/09/Android注解实践——运行时注解框架/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2017/04/09/Android注解实践——运行时注解框架/","excerpt":"之前写了一篇编译期注解的文章，里面有提到注解作用的三种时期，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留。网上大多的资料讲的也都是编译期的注解，因为这是一种不影响效率的方式，也是很多热门开源库采用的方式。但是有些时候编译期注解并不能帮我们解决碰到的问题，这个时候如果了解运行时注解，也许就能解决问题。基础的概念前一篇已经讲过，这里就不再介绍了。","text":"之前写了一篇编译期注解的文章，里面有提到注解作用的三种时期，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留。网上大多的资料讲的也都是编译期的注解，因为这是一种不影响效率的方式，也是很多热门开源库采用的方式。但是有些时候编译期注解并不能帮我们解决碰到的问题，这个时候如果了解运行时注解，也许就能解决问题。基础的概念前一篇已经讲过，这里就不再介绍了。 实现原理运行时注解操作的原理就是运用反射，去获取到我们注解所操作的元素（Filed、Method…），然后再去获得Annotation进行操作，完成我们的目的。主要运用的有这些方法: T getAnnotation(Class annotationClass)返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 Annotation[] getAnnotations()返回该程序元素上存在的所有注解。 boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。 Annotation[] getDeclaredAnnotations()返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 理论虽然简单，但是抽象，下面具体讲讲如何简单的实现。 举个栗子EventBusEventBus大家应该都不陌生，它是一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，而不需要以层层传递接口的形式去单独构建通信桥梁。这个库的优秀以及流行更是因为它使用方便、性能高、支持多线程等各种优点。这个库里面也运用了不少注解的技术，这篇文章就略微的讲一下EventBus是如何通过注解，指定不同线程去处理消息的。(以下源码都在是EventBus 3.0.0版本下)1234@Subscribe(threadMode = ThreadMode.BACKGROUND) //在ui线程执行public void processEvent(TestEvent event)&#123;&#125; 上面代码是指定在UI线程中处理消息。然后看一下注解是在org.greenrobot.eventbus.SubscriberMethodFinder中的findUsingReflectionInSingleClass()方法处理的。1234567891011121314151617181920212223242526272829303132333435363738394041private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; //获取所有方法 try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); //判断方法修饰的类型 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //限制参数数量 if (parameterTypes.length == 1) &#123; //取得注释 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; //获取线程类型 ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(\"@Subscribe method \" + methodName + \"must have exactly 1 parameter but has \" + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(methodName + \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"); &#125; &#125;&#125; 上面就通过反射获取到了注册类中的注解方法，然后获取注解值，在构造SubscriberMethod的时候就传入了threadMode，然后在Post的时候，会根据不同的类型去进行不同的处理：1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125; &#125; 根据不同的类型会有不同的Poster去在对应线程操作123private final HandlerPoster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; 以上就是运行期注解在EventBus中的一些应用以及简单的理解。 我们自己操作的时候，也可以通过同样的方式，先声明一个运行期注解，然后在需要操作的地方反射的获取到被注解的元素，进行需要的操作。 总结至此注解的文章就写完了，可以看到原理其实比较简单。而我们学习这个的目的，一方面是更好的去理解各种流行框架的原理以及设计思路，在面对一些重复的代码工作中可以变得更加高效，也是给自己的思维一个拓展，在面对项目的设计问题时，有一个武器可以使用，也可以更好的去理解各种解耦的思想。","categories":[{"name":"Android文章","slug":"Android文章","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android文章/"}],"tags":[{"name":"Android, Annotation, 注解, 运行时注解, EventBus","slug":"Android-Annotation-注解-运行时注解-EventBus","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-Annotation-注解-运行时注解-EventBus/"}]},{"title":"Android注解实践——打造编译时注解框架","slug":"Android注解实践——打造编译时注解框架","date":"2017-04-08T07:33:40.000Z","updated":"2017-04-13T01:20:50.674Z","comments":true,"path":"2017/04/08/Android注解实践——打造编译时注解框架/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2017/04/08/Android注解实践——打造编译时注解框架/","excerpt":"最近一直在做项目的重构工作，因为是做组件化，正好看到阿里云开源一个路由框架ARouter。看了一下源码，发现是项目主要也是运用到了编译时注解的技术。联想到之前最早用过的ButterKnife，到现在的Retrofit等等各种主流的开源框架，其实都有使用到这项强大技术，之前也只是简单了解了一下原理，这次就想自己也写一个这种框架，搞清楚实现原理。首先，注解处理器(Anonotation Processor)分为编译时(Compile time)注解和运行时(Runtime)通过反射机制运行的注解，因为编译期注解实际上是生成.java文件辅助我们实现功能，所以不会有效率上的损耗，上面提到的开源框架也都是基于这种基础实现的。这篇文章只涉及编译时注解(类似于ButterKnife)，教大家如何打造一个简单的编译时注解框架，如何调试，和一些在实践中碰到的问题。","text":"最近一直在做项目的重构工作，因为是做组件化，正好看到阿里云开源一个路由框架ARouter。看了一下源码，发现是项目主要也是运用到了编译时注解的技术。联想到之前最早用过的ButterKnife，到现在的Retrofit等等各种主流的开源框架，其实都有使用到这项强大技术，之前也只是简单了解了一下原理，这次就想自己也写一个这种框架，搞清楚实现原理。首先，注解处理器(Anonotation Processor)分为编译时(Compile time)注解和运行时(Runtime)通过反射机制运行的注解，因为编译期注解实际上是生成.java文件辅助我们实现功能，所以不会有效率上的损耗，上面提到的开源框架也都是基于这种基础实现的。这篇文章只涉及编译时注解(类似于ButterKnife)，教大家如何打造一个简单的编译时注解框架，如何调试，和一些在实践中碰到的问题。 基本概念注解处理器是Javac的一个工具，它用来在编译时扫描和处理注解，更多信息可以查看官方文档。一个注解的注解处理器，以Java代码作为输出，生成文件（通常是.java文件）作为输出。这意味着你可以生成java代码，当然生成的.java代码是在新的文件中，你不能修改原有的Java类。但是我们可以生成辅助类，来帮助我们完成工作，就像ButterKnife这样，我们省去了findviewById的重复工作，仅需一行注解，他就能帮我们完成操作。我们掌握这项技术，也可以在之后的工作中减少重复无意义的工作，更重要的是注解能够帮我们更好的解耦我们的各个模块。 注解类型首先举一个我们最常见的注解：1@Override 大家都知道这是重写的意思，我们具体看看它的代码。1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 出现了两个东西，@Target、 @Retention，前者代表该注解可以作用于什么地方，后者代表要在什么级别保存该注解信息。我们看看枚举里支持的类型。123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 123456789101112131415161718192021public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; 上面贴出了枚举值，里面的注释也写的很清楚，我简单说一下RetentionPolicy，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留，可以通过反射获取到的。所以我们编译期注解框架的Retention是CLASS类型。 AbstractProcessor接下来我们要了解一个注解的核心，AbstractProcessor类，它是一个抽象的注释处理器，设计来为大多数注解实践类提供方便的超类。我们所有的Processor API都是继承自AbstractProcessor类。我们继承AbstractProcessor类之后，需要实现四个方法：123456789101112131415public class MyProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; &#125;&#125; init(ProcessingEnvironment env)：javac 会在 Processor 创建时调用并执行的初始化操作，该方法会传入 一个参数 ProcessingEnvironment env ，通过 env 可以访问 Elements、Types、Filer等工具类。 getSupportedAnnotationTypes()：返回需要注册的注解集合。 getSupportedSourceVersion()：返回支持的java版本，通常返回SourceVersion.latestSupported()。 process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)：这个方法相当于Processor类的main方法，所有扫描和处理注解、生成.java文件的操作，都是在这里完成。 实践步骤了解了上面的基础知识，这里讲讲具体如何实现。我们的目的是通过注解实现替代我们findViewById的繁琐操作，类似于ButterKnife的@Bind操作。12@BindView(R.id.test_text)TextView textView; 整个项目分为四个模块，app，annotation（注解），api，compiler（注解处理器）。首先讲一下整体的思路，在我们的Activity中，使用注解定义控件，在onCreate方法中，调用Api模块的bind(this)。bind方法内其实就是通过反射获取到注解处理器生成的辅助类，通过辅助类完成控件的初始化工作。 annotation在项目中，New Module，选择Java Library，新建类，定义注解12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.FIELD)public @interface BindView &#123; int value();&#125; @BindView对成员变量进行注解，接收一个int类型的参数。 apiNew Module，选择Android Library，首先我们需要定一个一个接口，生成的注解类需要实现这个接口，然后我们通过这个接口去完成注入的操作从而达到目的。123public interface ViewBind&lt;T&gt; &#123; void inject(T t, Object obj);&#125; 还需要一个类，提供给需要使用注解的activity，完成绑定操作，通过bind(this)方法，获取到注解类，调用inject方法注入。123456789101112131415161718192021222324252627public class ViewBinder &#123; private final static String SUFFIX = \"$$ViewBinder\"; public static void bind(Activity activity)&#123; ViewBind proxyActivity = findProxyActivity(activity); proxyActivity.inject(activity, activity); &#125; public static void injectView(Object object, View view) &#123; ViewBind proxyActivity = findProxyActivity(object); proxyActivity.inject(object, view); &#125; private static ViewBind findProxyActivity(Object activity)&#123; try &#123; Class clazz = activity.getClass(); Class viewBindClazz = Class.forName(clazz.getName() + SUFFIX); return (ViewBind) viewBindClazz.newInstance(); &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; throw new RuntimeException(String.format(\"can not find %s, something error when compiler.\", activity.getClass().getSimpleName() + SUFFIX)); &#125;&#125; compiler注解处理器，这是核心的模块。New Module，选择Java Library。在gradle中添加：12compile 'com.google.auto.service:auto-service:1.0-rc2'compile 'com.squareup:javapoet:1.7.0' 前者是自动生成 META-INF/services/javax.annotation.processing.Processor文件的库，后者JavaPoet是一个生成java代码的库，免去了我们拼字符串的繁琐。 Processor类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 使用 Google 的 auto-service 库可以自动生成 META-INF/services/javax.annotation.processing.Processor 文件 */@AutoService(Processor.class)public class BindProcessor extends AbstractProcessor&#123; //元素处理辅助类 private Elements elementUtils; //日志辅助类 private Messager messager; private Map&lt;String, BindProxy&gt; mProxyMap = new HashMap&lt;String, BindProxy&gt;();; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); elementUtils = processingEnv.getElementUtils(); messager = processingEnv.getMessager(); &#125; /** * @return 指定哪些注解应该被注解处理器注册 */ @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; HashSet&lt;String&gt; supportType = new HashSet&lt;String&gt;(); supportType.add(BindView.class.getCanonicalName()); return supportType; &#125; /** * @return 指定使用的 Java 版本。通常返回 SourceVersion.latestSupported()。 */ @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; messager.printMessage(Diagnostic.Kind.NOTE, \"process...\"); //获取BindView注释的元素集合 Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(BindView.class); if (elements == null || elements.size() &lt; 1)&#123; return true; &#125; //遍历集合 for (Element element : elements)&#123; //检查是否是作用于FIELD if (checkElement(element))&#123; VariableElement variable = (VariableElement) element; TypeElement typeElement = (TypeElement) element.getEnclosingElement(); String className = typeElement.getQualifiedName().toString(); //从缓存中取得BindProxy类,不存在则new BindProxy proxy = mProxyMap.get(className); if (proxy == null)&#123; proxy = new BindProxy(elementUtils, typeElement); mProxyMap.put(className, proxy); &#125; BindView bindView = variable.getAnnotation(BindView.class); proxy.injectInfo.put(bindView.value(), variable); &#125; else &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"error...\"); &#125; &#125; //遍历mProxyMap 取出所有的BindProxy类 去生成代码 for (String key : mProxyMap.keySet())&#123; BindProxy proxy = mProxyMap.get(key); try &#123; proxy.generateCode().writeTo(processingEnv.getFiler()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; private boolean checkElement(Element element)&#123; if (element.getKind() != ElementKind.FIELD) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"%s must be declared on field.\", element); return false; &#125; return true; &#125;&#125; 生成代码类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BindProxy &#123; public Map&lt;Integer, VariableElement&gt; injectInfo = new HashMap&lt;&gt;(); private TypeElement element; private String packageName, className; private static final String PROXY = \"$$ViewBinder\"; public BindProxy(Elements elements, TypeElement typeElement) &#123; element = typeElement; PackageElement packageElement = elements.getPackageOf(typeElement); packageName = packageElement.getQualifiedName().toString(); className = typeElement.getSimpleName() + PROXY; &#125; public JavaFile generateCode() &#123; //生成方法代码 MethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(\"inject\") .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .addParameter(TypeName.get(element.asType()), \"host\", Modifier.FINAL) .addParameter(TypeName.OBJECT, \"obj\"); //在方法中插入一行findViewById代码,遍历所有的元素 for (int id : injectInfo.keySet()) &#123; VariableElement element = injectInfo.get(id); String name = element.getSimpleName().toString(); TypeMirror type = element.asType(); injectMethodBuilder.addStatement(\"host.$N = ($T)((($T) obj).findViewById($L))\" , name, type, TypeUtil.ANDROID_ACTIVITY, id); &#125; //生成class代码 TypeSpec clazz = TypeSpec.classBuilder(className) //这里添加的接口类,并添加了泛型 .addSuperinterface(ParameterizedTypeName.get(TypeUtil.VIEWBIND, TypeName.get(element.asType()))) .addModifiers(Modifier.PUBLIC) .addMethod(injectMethodBuilder.build()) .build(); return JavaFile.builder(packageName, clazz).build(); &#125;&#125; 配置主要的代码就在上面，注释写的应该比较清楚了，剩下的就是对项目进行配置。我们需要在根项目的build.gradle中添加dependencies1classpath 'com.neenbedankt.gradle.plugins:android- apt:1.8' 在app的build.gradle中添加1apply plugin: 'com.neenbedankt.android-apt' 然后添加dependencies123compile project(':api') compile project(':annotation') apt project(':compiler') 效果然后运行或者build项目就可以看到注解生成的类，目录是build/generated/source/apt/debug/包名123456public class MainActivity$$ViewBinder implements ViewBind&lt;MainActivity&gt; &#123; @Override public void inject(final MainActivity host, Object obj) &#123; host.textView = (TextView)(((Activity) obj).findViewById(2131492942)); &#125;&#125; 常见问题编译报错在我开始尝试这个项目的时候，参考了很多别人的文章，都是正常的编码思路和源码，没有讲容易碰到的问题。我在参照别人写完demo，build的时候一直报错。12Error:Execution failed for task &apos;:app:compileDebugJavaWithJavac&apos;.&gt; java.lang.NullPointerException 这个错之前也碰到过，但是具体原因忘了，起初以为是gradle配置的问题，改来改去还是解决不了，搜索也解决不了。后来注释掉了processor中的部分代码，发现build成功。原来是Processor中异常了。所以报这种错的时候，检查一下自己的代码，肯定是有异常。 调试Processor当Processor出现问题的时候，最直观寻找问题的方法就是debug。Debug Processor步骤 在Android studio中添加Remote Debugger，并确定port的设置是跟下面的参数一致 在 gradle.properties文件中添加如下12org.gradle.parallel=trueorg.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 然后添加断点，在你需要调试的地方，项目build的时候就可以调试了。 为什么要分开注解和处理器一方面是更好的解耦，我们的注解处理器可以用于其他项目。还有一个就是能避免65K方法数问题。 总结这个项目就是一个简单的APT demo，主要运用的就是注解的基础知道以及AbstractProcessor类和JavaPoet库生成Java代码，通过这个我们可以学习如何编写APT项目，实现起来并不复杂，但是注解处理器是一个非常强大的工具。整个的重心在于，通过这个我们能够知道有这么一种方式可以再编译期生成代码，简化我们的工作。更重要的是要有这么一个思路，可以去设计我们的架构，对架构实现更好的解耦，ARouter就是通过APT实现依赖反转，我也是抱着这些目的来学习注解。之后我会写运行时的注解处理器。 项目地址https://github.com/PengsongAndroid/MyAnnotation 参考：Java注解处理器How to debug the apt AbstractProcessor code generation?Android 如何编写基于编译时注解的项目","categories":[{"name":"Android文章","slug":"Android文章","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android文章/"}],"tags":[{"name":"Android, Annotation, 注解","slug":"Android-Annotation-注解","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-Annotation-注解/"}]},{"title":"坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题","slug":"坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题","date":"2017-03-27T12:50:44.000Z","updated":"2017-03-27T08:55:23.248Z","comments":true,"path":"2017/03/27/坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2017/03/27/坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题/","excerpt":"最近在做重构项目的过程中，重构蓝牙扫描模块的时候。发现调用扫描方法的时候，根本没有返回搜索到的设备。开始以为是厂商sdk的bug，或者是自己新写的代码问题。然后没有用厂商sdk，自己写代码来扫描，琢磨了半天看日志，debug，依然没找到问题。后来突然想到是不是权限的问题，之前项目的targetSdkVersion 22，新的项目是23，然后Android 6.0有一套新的权限机制，敏感权限需要申请，感觉可能是权限问题导致的。","text":"最近在做重构项目的过程中，重构蓝牙扫描模块的时候。发现调用扫描方法的时候，根本没有返回搜索到的设备。开始以为是厂商sdk的bug，或者是自己新写的代码问题。然后没有用厂商sdk，自己写代码来扫描，琢磨了半天看日志，debug，依然没找到问题。后来突然想到是不是权限的问题，之前项目的targetSdkVersion 22，新的项目是23，然后Android 6.0有一套新的权限机制，敏感权限需要申请，感觉可能是权限问题导致的。搜索了一下，下面是具体的权限列表 Normal Permission123456789101112131415161718192021222324252627282930313233ACCESS_LOCATION_EXTRA_COMMANDSACCESS_NETWORK_STATEACCESS_NOTIFICATION_POLICYACCESS_WIFI_STATEBLUETOOTHBLUETOOTH_ADMINBROADCAST_STICKYCHANGE_NETWORK_STATECHANGE_WIFI_MULTICAST_STATECHANGE_WIFI_STATEDISABLE_KEYGUARDEXPAND_STATUS_BARGET_PACKAGE_SIZEINSTALL_SHORTCUTINTERNETKILL_BACKGROUND_PROCESSESMODIFY_AUDIO_SETTINGSNFCREAD_SYNC_SETTINGSREAD_SYNC_STATSRECEIVE_BOOT_COMPLETEDREORDER_TASKSREQUEST_INSTALL_PACKAGESSET_ALARMSET_TIME_ZONESET_WALLPAPERSET_WALLPAPER_HINTSTRANSMIT_IRUNINSTALL_SHORTCUTUSE_FINGERPRINTVIBRATEWAKE_LOCKWRITE_SYNC_SETTINGS Dangerous Permission123456789101112131415161718192021222324252627282930313233343536373839404142group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTSgroup:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAILgroup:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDARgroup:android.permission-group.CAMERA permission:android.permission.CAMERAgroup:android.permission-group.SENSORS permission:android.permission.BODY_SENSORSgroup:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATIONgroup:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGEgroup:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIOgroup:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS 看了一下蓝牙权限不是敏感权限，应该不需要在运行时获取啊。然后查了下官方文档。有这么一段内容： 所以在通过蓝牙扫描附近外部设备时，需要获取这两个权限。12ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION 检查和申请权限可以调用这两个方法，具体如何使用可以自行搜索。12checkSelfPermission()requestPermissions() 处理权限的代码并不复杂，但是需要自己去封装。我自己是使用的一个开源库：https://github.com/lovedise/PermissionGen使用起来比较方便，感兴趣的可以看看。","categories":[{"name":"Android日常问题","slug":"Android日常问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android日常问题/"}],"tags":[{"name":"Android, Android权限机制","slug":"Android-Android权限机制","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-Android权限机制/"}]},{"title":"Android在应用退出后发送请求解决方案","slug":"Android在应用退出后发送请求解决方案","date":"2017-03-15T09:07:44.000Z","updated":"2017-03-16T06:20:37.248Z","comments":true,"path":"2017/03/15/Android在应用退出后发送请求解决方案/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2017/03/15/Android在应用退出后发送请求解决方案/","excerpt":"最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。 常规退出场景常规情况下应用退出有这么几种情况：1.app内退出按钮或者双击返回；2.最近应用列表，划掉应用卡片（常见）；3.应用崩溃；我们一个个来分析解决。","text":"最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。 常规退出场景常规情况下应用退出有这么几种情况：1.app内退出按钮或者双击返回；2.最近应用列表，划掉应用卡片（常见）；3.应用崩溃；我们一个个来分析解决。 解决方案对于app内部退出这个是我们可控的。但是用户在退出时发请求需要考虑到网络情况，肯定不可能等到请求成功才退出应用。而我们app退出是有下面的操作： 1234//系统退出 清空所有缓存 取消所有请求UenUtils.cleanAppConfigWhenExit();MyApplication.cancelAllPostRequests();ActivityStack.popAll(); 最后一步内其实是杀掉了当前进程 1android.os.Process.killProcess(android.os.Process.myPid()); 因为这一步应用是被杀掉的，肯定是不能在这里做发请求操作，只能开启service来帮我们完成操作。具体的实现方案就是，在应用启动时startService，这是一个远端的service 123456789&lt;service android:name=\".service.MyService\" android:process=\":remote\" android:enabled=\"true\"&gt; &lt;intent-filter&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;action android:name=\"MyService\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 然后我们在应用退出的时候，发送一个广播（因为这个进程间的通信很简单，所以就用这种比较方便的方式），service中处理广播，处理完成后销毁自己，思路就是这样。关键部分代码如下：activity:12345678@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; Intent intent = new Intent(); intent.setAction(\"test\"); sendBroadcast(intent); android.os.Process.killProcess(android.os.Process.myPid()); return super.onKeyDown(keyCode, event);&#125; service：12345678910111213141516171819202122@Overridepublic void onCreate() &#123; Log.i(TAG, \"onCreate \"); super.onCreate(); IntentFilter filter = new IntentFilter(); filter.addAction(\"test\"); registerReceiver(receiver, filter);&#125; BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (\"test\".equals(intent.getAction()))&#123; Log.e(TAG, \"onReceive\"); /**发请求*/ .... /**请求成功后解绑 */ unregisterReceiver(receiver); android.os.Process.killProcess(android.os.Process.myPid()); &#125; &#125;&#125;; 对于在任务列表划掉应用查了一些资料之后发现Service中有一个回调方法1234@Overridepublic void onTaskRemoved(Intent rootIntent) &#123;&#125; 官方文档解释如下，大意就是如果这个service在运行并且用户移除了这个任务，会回调这个方法，但是如果你设置了FLAG_STOP_WITH_TASK这个属性，你将不会接收到这个回调，并且service会直接停止。 提到了FLAG_STOP_WITH_TASK这个属性，我们来看看这是什么：如果设置了该属性，用户删除了基于某个应用程序的任务，系统将自动停止该服务，然后这个是通过stopWithTask属性来控制的。所以我们在service中配置，添加一行 1android:stopWithTask=\"true\" 然后我们测试一下，启动服务后从任务列表移除应用，方法确实被回调。我们可以在这个方法内发送请求，不过需要注意的是，我测试的机器上，移除应用后方法回调然后service就挂掉了，1s左右service又重启了，走了onCreate、onStartCommand回调。我是直接在回调方法里写请求，这样会出现接收不到请求的返回的情况。所以我建议的方式是，在回调方法里写一个SharedPreferences，然后再重新创建的时候再去通过读取这个值来发送请求。具体实现代码如下：1234567891011121314151617181920212223242526 // 配置文件 private static SharedPreferences g_settings = null; private static SharedPreferences.Editor g_editor = null; @Override public void onCreate() &#123; super.onCreate(); g_settings = getSharedPreferences(\"ps\", Context.MODE_APPEND); test = g_settings.getBoolean(\"test\", false); Log.i(TAG, \"onCreate \" + test); if (test)&#123; g_editor.putBoolean(\"test\", false); g_editor.commit();/**发请求 然后销毁service*/... &#125; g_editor = g_settings.edit(); &#125; @Override public void onTaskRemoved(Intent rootIntent) &#123; Log.e(TAG, \"onTaskRemoved\"); g_editor.putBoolean(\"test\", true); g_editor.commit(); super.onTaskRemoved(rootIntent); &#125; 对于异常崩溃的情况可以在application中实现UncaughtExceptionHandler，然后在回调方法中发送广播，思路跟上面的差不多。具体的实现就是这些，只写了重要部分的代码，其他的也都很简单就不贴出来了。","categories":[{"name":"Android文章","slug":"Android文章","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android文章/"}],"tags":[{"name":"Android, 应用退出","slug":"Android-应用退出","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-应用退出/"}]},{"title":"Android Studio 添加library添加.so文件问题解决","slug":"Android Studio 添加library添加.so文件问题解决","date":"2016-05-26T23:33:44.000Z","updated":"2017-03-16T06:13:14.353Z","comments":true,"path":"2016/05/27/Android Studio 添加library添加.so文件问题解决/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2016/05/27/Android Studio 添加library添加.so文件问题解决/","excerpt":"今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。","text":"今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。 导入library首先在项目中import project，如图 需要注意的是，如果library是eclipse项目，需要先在eclipse中导出为AS项目。 然后在Project Structure选项中查看项目的Dependencies，点击右上角的加号，选择Module dependency,选择刚刚导入的library，点击ok让项目自动构建即可。 导入module 等待构建完毕之后，我Run的时候却发现很多报错信息，反复修改各种配置，错误信息也是一会一个，发现错误信息全部集中在 android/support/v4 这个依赖上，错误信息如下： 12345678Error:Execution failed for task ':transformClassesWithJarMergingForDebug'.com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/content/Loader$OnLoadCompleteListener.classError:Execution failed for task ':transformClassesWithJarMergingForDebug'.Error:Execution failed for task ':transformClassesWithJarMergingForDebug'.com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/DrawableCompat$BaseDrawableImpl.classError:Execution failed for tasktransformClassesWithJarMergingForDebug'.com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/accessibilityservice/AccessibilityServiceInfoCompat.class 发现了问题出在哪里之后，就从这里入手，一顿搜索，发现应该是存在重复的jar包。想起来导入的library是用的本地的support-v4 jar包，原本的项目也用的是本地的support-v4 jar包，觉得问题可能就是在这。然后删除了两个项目本地的jar包，通过gradle来导入。两个项目的gradle都添加。 1compile 'com.android.support:support-v4:22.1.1' 然后等待项目构建完成，再次Run，没有问题。不知道为什么通过gradle添加依赖就能解决，不过已经用了AS，最好还是按照AS的配置来构建项目，避免不必要的问题。 导入.so文件上面导入的library项目，还需要在原项目中添加.so文件，两个文件夹下各有一个.so文件，添加到项目中。 运行时报错如下： java.lang.UnsatisfiedLinkError: Native method not found: com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create:()J at com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create(Native Method) at com.baidu.platform.comjni.map.commonmemcache.a.a(Unknown Source) at com.baidu.platform.comapi.e.c.b(Unknown Source) at com.baidu.mapapi.a.c(Unknown Source) at com.baidu.mapapi.SDKInitializer.initialize(Unknown Source) 提示跟百度地图的Native方法找不到了，我仅仅添加了.so文件结果导致百度地图报错。排查了几次之后，又去百度官网看文档，发现demo中lib目录下各种cpu类型目录底下都会有同名的.so文件，怀疑是因为我只在armeabi文件夹下添加了百度地图的.so库，新建了armeabi-v7a文件夹后没有添加百度地图的文件，导致去这个文件夹下加载不到.so库，然后复制了一份百度地图的.so库至armeabi-v7a文件夹，成功解决。","categories":[{"name":"Android日常问题","slug":"Android日常问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android日常问题/"}],"tags":[{"name":"Android, .so, Android studio","slug":"Android-so-Android-studio","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-so-Android-studio/"}]},{"title":"Android Studio 2.0异常","slug":"Android Studio 2.0异常","date":"2016-05-24T23:33:44.000Z","updated":"2017-03-16T06:15:59.224Z","comments":true,"path":"2016/05/25/Android Studio 2.0异常/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2016/05/25/Android Studio 2.0异常/","excerpt":"","text":"今天在导入同事的项目完成后没报错，运行的时候却报了一段错误，自己弄了会儿都没解决。 123:app:transformClassesWithInstantRunForDebug FAILEDError:Execution failed for task ':app:transformClassesWithInstantRunForDebug'.Invalid signature file digest for Manifest main attributes 后来经过搜索发现解决方案，禁用2.0的快速启动新功能，按照下图取消勾选即可。","categories":[{"name":"Android日常问题","slug":"Android日常问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android日常问题/"}],"tags":[{"name":"Android studio, 环境问题","slug":"Android-studio-环境问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-studio-环境问题/"}]}]}